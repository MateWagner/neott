import time
import copy
import strip.effect_lib as effects
import strip.render_lib as render
from utils.log_provider import log
from utils.data_types import NeopixelControl, ColorRgbw, EffectControl


def loop_forever(message_queue):
    """neopixel main control loop

    Args:
        message_queue (Queue): consume messages witch generated by other threads
    """
    log.info('Neopixel start')

    neopixel_control = NeopixelControl()
    effect_control = EffectControl()
    neo_buffer = fill_neo_buffer(neopixel_control)

    while True:

        if not message_queue.empty():
            neopixel_control = update_variables(
                message_queue, neopixel_control)

        log.debug('Neopixel: Show Type: %s Effect State: %s render on Index: %s',
                  neopixel_control.show_type, neopixel_control.effect_state, effect_control.effect_cycle_index)

        # set brightness
        render.set_brightness(neopixel_control.brightness)

        if neopixel_control.effect_state != 'STOP':

            if neopixel_control.show_type == 'COLOR' or neopixel_control.main_switch == 'OFF':
                neopixel_control, effect_control, neo_buffer = handle_solid_color_and_off(
                    neopixel_control, effect_control, neo_buffer)

            if neopixel_control.show_type == 'RAINBOW' and neopixel_control.main_switch == 'ON':
                neopixel_control, effect_control, neo_buffer = handle_rainbow_cycle(
                    neopixel_control, effect_control, neo_buffer)

            # sleep time on active render between pixels
            time.sleep(neopixel_control.wait)

        else:
            time.sleep(3)


def handle_rainbow_cycle(neopixel_control, effect_control, neo_buffer):
    buffer_copy = copy.deepcopy(neo_buffer)
    if neopixel_control.effect_state == 'START':
        effect_control = get_random_callback(effect_control)
        buffer_copy, wheel_pos = effects.rainbow_cycle(
            buffer_copy, effect_control.wheel_pos)
        effect_control = effect_control._replace(
            wheel_pos=wheel_pos)

    neopixel_control, effect_control = render_next_pixel(
        neopixel_control, effect_control, buffer_copy, True)

    return neopixel_control, effect_control, buffer_copy


def handle_solid_color_and_off(neopixel_control, effect_control, neo_buffer):
    buffer_copy = copy.deepcopy(neo_buffer)
    if neopixel_control.effect_state == 'START':
        effect_control = get_random_callback(effect_control)
        buffer_copy = fill_neo_buffer(neopixel_control)

    neopixel_control, effect_control = render_next_pixel(
        neopixel_control, effect_control, buffer_copy, False)

    return neopixel_control, effect_control, buffer_copy


def render_next_pixel(neopixel_control, effect_control, buffer_copy, is_consecutive):
    new_index, state = effect_control.render_callback(
        buffer_copy, effect_control.effect_cycle_index, neopixel_control.effect_state, is_consecutive)

    effect_control = effect_control._replace(
        effect_cycle_index=new_index)

    if neopixel_control.neopixel_control != state:
        neopixel_control = neopixel_control._replace(
            effect_state=state)

    return neopixel_control, effect_control


def update_variables(message_queue, neopixel_control):
    variables_copy = neopixel_control._asdict()
    for topic_name, value in message_queue.get().items():
        log.info('Update arrived on: %s topic, value: %s', topic_name, value)
        variables_copy[topic_name] = value

    message_queue.task_done()
    return NeopixelControl(**variables_copy)


def fill_neo_buffer(neopixel_control):
    return (effects.fill_with_one_color(ColorRgbw())
            if neopixel_control.main_switch == 'OFF'
            else effects.fill_with_one_color(neopixel_control.dec_rgbw))


def get_random_callback(effect_control):
    return effect_control._replace(
        render_callback=render.get_random_callback())
